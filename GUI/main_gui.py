# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main_gui.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(598, 468)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.comboBox_ports = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox_ports.setObjectName("comboBox_ports")
        self.verticalLayout.addWidget(self.comboBox_ports)
        self.pushButton_connect = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_connect.setObjectName("pushButton_connect")
        self.verticalLayout.addWidget(self.pushButton_connect)
        self.pushButton_disconnect = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_disconnect.setObjectName("pushButton_disconnect")
        self.verticalLayout.addWidget(self.pushButton_disconnect)
        self.pushButton_startRecording = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_startRecording.setObjectName("pushButton_startRecording")
        self.verticalLayout.addWidget(self.pushButton_startRecording)
        self.pushButton_calculateHR = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_calculateHR.setObjectName("pushButton_calculateHR")
        self.verticalLayout.addWidget(self.pushButton_calculateHR)
        self.label_heartRate = QtWidgets.QLabel(self.centralwidget)
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label_heartRate.setFont(font)
        self.label_heartRate.setAlignment(QtCore.Qt.AlignCenter)
        self.label_heartRate.setObjectName("label_heartRate")
        self.verticalLayout.addWidget(self.label_heartRate)
        self.pushButton_stop_save_recording = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_stop_save_recording.setObjectName("pushButton_stop_save_recording")
        self.verticalLayout.addWidget(self.pushButton_stop_save_recording)
        self.widget = PlotWidget(self.centralwidget)
        self.widget.setStyleSheet("background-color: rgb(0, 0, 0);")
        self.widget.setObjectName("widget")
        self.verticalLayout.addWidget(self.widget)
        self.verticalLayout.setStretch(0, 1)
        self.verticalLayout.setStretch(1, 1)
        self.verticalLayout.setStretch(2, 1)
        self.verticalLayout.setStretch(3, 1)
        self.verticalLayout.setStretch(6, 1)
        self.verticalLayout.setStretch(7, 8)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButton_connect.setText(_translate("MainWindow", "Conectar"))
        self.pushButton_disconnect.setText(_translate("MainWindow", "Desconectar"))
        self.pushButton_startRecording.setText(_translate("MainWindow", "Comenzar grabación"))
        self.pushButton_calculateHR.setText(_translate("MainWindow", "Calcular Frecuencia Cardíaca"))
        self.label_heartRate.setText(_translate("MainWindow", "FC: -- BPM"))
        self.pushButton_stop_save_recording.setText(_translate("MainWindow", "Detener grabación y guardar"))

import sys
import struct
import serial
import serial.tools.list_ports
import csv
from pyqtgraph import PlotWidget

import numpy as np
from scipy.signal import butter, filtfilt, find_peaks

class ECGRecorder(QtCore.QObject):
    def __init__(self, ui):
        super().__init__()
        self.ui = ui
        self.serial = None
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.read_serial)
        self.data = []
        self.plot_data = []
        self.curve = self.ui.widget.plot(pen='g')
        self.ui.widget.setYRange(0, 5)
        self.sampling_rate = 100  # 100 Hz (100 muestras cada 10ms según tu timer)

    def list_ports(self):
        self.ui.comboBox_ports.clear()
        ports = serial.tools.list_ports.comports()
        for port in ports:
            self.ui.comboBox_ports.addItem(port.device)

    def connect_serial(self):
        port_name = self.ui.comboBox_ports.currentText()
        if not port_name:
            return
        try:
            self.serial = serial.Serial(port_name, baudrate=9600, timeout=1)
            print("Conectado exitosamente")
            self.ui.pushButton_connect.setStyleSheet("background-color: green;")
            self.ui.pushButton_connect.setEnabled(False)
        except serial.SerialException as e:
            print(f"Error al conectar: {e}")
            return

    def disconnect_serial(self):
        self.timer.stop()
        if self.serial and self.serial.is_open:
            self.serial.close()
            self.serial = None
            self.ui.pushButton_connect.setStyleSheet("")
            self.ui.pushButton_connect.setEnabled(True)

    def start_recording(self):
        self.data = []
        self.plot_data = []
        self.timer.start(10)  # Llamar a read_serial cada 10 ms

    def stop_and_save(self):
        self.timer.stop()
        if self.data:
            # Abrir diálogo para seleccionar ubicación y nombre del archivo
            options = QtWidgets.QFileDialog.Options()
            file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
                None,
                "Guardar datos ECG",
                "ecg_data.csv",
                "CSV Files (*.csv);;All Files (*)",
                options=options
            )
            
            if file_path:  # Si el usuario seleccionó un archivo
                with open(file_path, "w", newline='') as f:
                    writer = csv.writer(f)
                    writer.writerow(["Sample"])
                    for sample in self.data:
                        writer.writerow([sample])
                print(f"Datos guardados en {file_path}")
            else:
                print("Guardado cancelado por el usuario")
        else:
            print("No hay datos para guardar")

    def butter_bandpass(self, lowcut, highcut, fs, order=4):
        """Diseña un filtro pasabanda Butterworth"""
        nyquist = 0.5 * fs
        low = lowcut / nyquist
        high = highcut / nyquist
        b, a = butter(order, [low, high], btype='band')
        return b, a

    def bandpass_filter(self, data, lowcut=0.5, highcut=40.0, fs=100, order=4):
        """Aplica filtro pasabanda a la señal"""
        b, a = self.butter_bandpass(lowcut, highcut, fs, order=order)
        y = filtfilt(b, a, data)
        return y

    def calculate_heart_rate(self):
        """Calcula la frecuencia cardíaca usando detección de picos"""
        if len(self.data) < 200:  # Mínimo 2 segundos de datos
            self.ui.label_heartRate.setText("FC: Insuficientes datos")
            print("Se necesitan al menos 2 segundos de grabación")
            return

        try:
            # Tomar últimos 10 segundos de datos (o todos si hay menos)
            window_samples = min(10 * self.sampling_rate, len(self.data))
            signal_window = np.array(self.data[-window_samples:])

            # Aplicar filtro pasabanda (elimina ruido y deriva de línea base)
            filtered_signal = self.bandpass_filter(
                signal_window, 
                lowcut=0.5, 
                highcut=40.0, 
                fs=self.sampling_rate
            )

            # Normalizar la señal
            filtered_signal = (filtered_signal - np.mean(filtered_signal)) / np.std(filtered_signal)

            # Detectar picos (complejos QRS)
            # height: altura mínima del pico (ajustar según tu señal)
            # distance: distancia mínima entre picos (evita detectar el mismo QRS múltiples veces)
            # 60 samples = 0.6 segundos mínimo entre latidos (max 100 BPM)
            peaks, properties = find_peaks(
                filtered_signal,
                height=0.5,  # Ajustar según la amplitud de tu señal
                distance=int(0.4 * self.sampling_rate),  # 0.4 seg = mínimo 150 BPM
                prominence=0.3  # Prominencia mínima del pico
            )

            if len(peaks) < 2:
                self.ui.label_heartRate.setText("FC: No se detectaron latidos")
                print("No se detectaron suficientes picos R")
                return

            # Calcular intervalos R-R (en muestras)
            rr_intervals = np.diff(peaks)

            # Convertir a intervalos de tiempo (segundos)
            rr_intervals_sec = rr_intervals / self.sampling_rate

            # Calcular frecuencia cardíaca promedio
            mean_rr = np.mean(rr_intervals_sec)
            heart_rate = 60.0 / mean_rr  # Convertir a BPM

            # Actualizar la interfaz
            self.ui.label_heartRate.setText(f"FC: {heart_rate:.1f} BPM")
            print(f"Frecuencia cardíaca calculada: {heart_rate:.1f} BPM")
            print(f"Picos detectados: {len(peaks)}")
            print(f"Intervalo R-R promedio: {mean_rr*1000:.1f} ms")

        except Exception as e:
            self.ui.label_heartRate.setText("FC: Error en cálculo")
            print(f"Error calculando frecuencia cardíaca: {e}")

    def read_serial(self):
        if not self.serial:
            return

        try:
            self.serial.write(b'S')  # Handshake

            # Esperar hasta tener 200 bytes
            expected_bytes = 2 * 100
            if self.serial.in_waiting < expected_bytes:
                return

            raw = self.serial.read(expected_bytes)  # Leer exactamente 200 bytes
            samples = struct.unpack('<' + 'H' * 100, raw)  # 100 valores uint16

            # Convertir a voltaje
            voltages = [round(s * (5.0 / 1023.0), 2) for s in samples]

            self.data.extend(voltages)
            self.plot_data.extend(voltages)
            self.plot_data = self.plot_data[-3000:]
            self.curve.setData(self.plot_data)

        except Exception as e:
            print(f"Error leyendo datos: {e}")


if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)

    recorder = ECGRecorder(ui)
    recorder.list_ports()

    ui.pushButton_connect.clicked.connect(recorder.connect_serial)
    ui.pushButton_disconnect.clicked.connect(recorder.disconnect_serial)
    ui.pushButton_startRecording.clicked.connect(recorder.start_recording)
    ui.pushButton_stop_save_recording.clicked.connect(recorder.stop_and_save)
    ui.pushButton_calculateHR.clicked.connect(recorder.calculate_heart_rate)

    MainWindow.show()
    sys.exit(app.exec_())
